### AQS原理解析

```java
LockSupport.park();//阻塞线程,且不可重入,获取一个许可
/////
Thread thread = Thread.currentThread();
    LockSupport.unpark(thread);
    System.out.println("a");
    LockSupport.park();
    System.out.println("b");
    LockSupport.park();
    System.out.println("c");
/*
LockSupport提供的是一个许可，如果存在许可，线程在调用park的时候，会立马返回，此时许可也会被消费掉，如果没有许可，则会阻塞。调用unpark的时候，如果许可本身不可用，则会使得许可可用
*/
```

### hashmap源码

数组初始化长度16最大2的30次方

数组加单向链表加红黑树

一个node对象存储了当前hash key  value  node next(单向链表的下一个node节点的引用),插入的话下一个就是null

```java
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;
```

什么时候扩容:数组长度大于**0.75**扩载因子扩容数组为之前的2倍,链表长度大于**8**的时候变成红黑树,当红黑树节点数小于**6**,红黑变链表

putval成功一次size会size++

存放数组位置的取模操作是key的hash运算然后取模数组长度